# 토스페이먼츠를 통한 결제 연동 시스템 및 프로필 조회수 증가 캐싱 안전성 확보

## 프로젝트 개요

- 토스페이먼츠 결제 API 연동 처리 과정에서 발생하는 다양한 시나리오의 안전성 확보
- 결제 승인, 검증, 재시도 가능한 오류 처리와 결제 상태 관리를 통해 시스템 안전성 확보
- 프로필 상세 조회 시 추가적인 조회수 증가 I/O 성능 저하 및 동시성 안전 확보

<br>

## 해결 과제
- 소프트웨어 아키텍쳐 설계 : 도메인의 결합도 및 의존성을 감소를 위한 아키텍쳐 설계
- 결제 데이터 정합성 : 결제 요청, 승인 과정에서 데이터 불일치 및 무결성 깨짐을 방지하기 위한 데이터 검증
- 조회수 증가의 동시성 및 동기화 : InMemory 캐싱 시 발생할 수 있는 조회수 동시성 문제 및 데이터 일관성 확보
- API 응답 지연 및 서버 다운 : 스케줄링 데이터 복구 로직을 통해 항상 일관되고, 안정적인 결제 처리 및 조회수 증가 설계

<br>

## 사용 기술

| 사용 기술 | 버전                                      | 사용 목적                          |
|:--------|:---------------------------------------|-------------------------------|
| Java   | 21                  | 경량 가상 스레드 기반으로 자원 효율성과 동시성 처리 성능 향상 |
| SpringBoot | 3.5.3 | DI, AOP, AutoConfiguration 등으로 생산성과 유연한 의존성 관리 |
| MySQL | 8.0.39 | 결제 등 중요한 작업 시 UNDO 로그 기반 트랜잭션으로 읽기-쓰기 일관성 보장 및 안정적인 데이터 처리  |
| Redis | 7.4.2 | 조회수 증가 로직의 세밀한 캐싱 제어 및 AOF/RDB 기반 데이터 유실 복구 스케줄링 가능 |
| Spring Data JPA | 3.2.3 | 엔티티 중심의 비즈니스 로직 구현을 통해 도메인 주도 개발 구조 정립 |
| Querydsl   | 5.0.0 | 동적 쿼리 간편 구현 및 MyBatis 대비 IDE, 컴파일 시점 오류 파악 가능 |

<br>

## 추가 라이브러리
- Lombok : 반복되는 코드 제거로 간결화
- Spring Validation : 요청 값 유효성 검증 처리 및 코드 정리
- H2 : 테스트 환경 구성 편의성 제공
- Httpclient5 : RestClient 기반의 HTTP 통신에서 커넥션 제어 및 타임아웃 설정을 위해 사용

<br>

## 구성 API


| 기능 | URL                                       | 메소드 | 설명                          |
|:--------|:---------------------------------------|--------|-------------------------------|
| 회원가입   | /api/members/signup                  | POST   | 간단한 회원가입 |
| 회원 프로필 상세 조회   | /api/profiles/{profileId}| GET    | 회원 ID로 프로필 조회 및 조회수 증가 |
| 회원 프로필 리스트 조회 | /api/profiles            | GET    | 필터링 조건에 부합하는 회원 목록 조회 |
| Toss 결제 정보 생성   | /api/payments/toss/checkout | POST | Toss 결제 전 사용자 결제 정보 생성 및 응답 |
| Toss 결제 승인 요청   | /api/payments/toss/confirm | POST | Toss 결제 승인 전 사용자 검증 및 결제 상태 처리 |

<br>

## 패키지 구조 및 의존성

![image](https://github.com/user-attachments/assets/eabf7d5e-f91f-4204-b0b1-0d4bdd5e7f57)

<br>

## 핵심 기능

### 프로필 조회수 증가 처리 및 장애 복구 설계

url : /api/profiles/{profileId}

**🎯 문제 정의**
- 실시간으로 DB에 조회수를 반영하면 DB 부하가 증가함
- 캐싱되지 않은 상태에서 여러 사용자가 동시에 조회수를 캐싱하려 할 경우 동시성 이슈 발생
- 어제 날짜의 Redis 조회수가 DB에 반영되지 않은 상태에서 오늘 조회 시, 조회수 일관성 문제가 발생
- 자정 무렵 Redis ↔ DB 동기화 스케줄링 중 조회 요청이 발생하면 일시적인 조회수 불일치 가능성 존재
- Redis 삽입 실패(Redis 장애 등) 시 조회수 반영이 누락될 수 있어, loss 데이터를 별도 관리할 필요성

**⚙️ 설계 및 구현 핵심 키워드**
- Redis 기반 조회수 캐싱 처리
- 날짜별 Redis 키 관리 (profile:view:{id}:{yyyyMMdd} 형식)
- setIfAbsent + INCR 조합으로 동시 접근 시 중복 캐싱 방지 및 조회수 일관성 확보
- Redis 장애 발생 시 조회수 누락 History 기록 및 DB와 동기화하는 스케줄링 처리

**🔁 조회수 증가 처리 흐름**

![image](https://github.com/user-attachments/assets/e745e45e-3b24-4d57-a24e-cf5902e705aa)

1. 클라이언트가 프로필 상세 조회 요청 (GET /api/profiles/{profileId})
2. Redis에서 오늘 날짜 기준의 조회수 키 존재 여부 확인
   - 존재할 경우 → INCR를 통해 원자적 증가
   - 존재하지 않을 경우
     - 어제 날짜 Redis 키 또는 DB 조회수를 기준으로 + 1 처리 후 캐싱 시도
     - 중복 삽입 방지를 위해 setIfAbsent 수행
       - 실패 시 이미 누군가 캐싱한 의미로 응답 반환 시 Redis INCR 후 반환 값을 응답으로 사용 ( 동시성 제어 )
3. Redis 장애 발생 시 → 조회수 누락 이력을 별도 테이블에 기록 (markAsLoss)
4. 최종 조회수를 반영한 Profile 반환
5. 추후 새벽 1시 사용자가 없는 시간대에 어제 날짜의 캐시된 조회수를 DB에 반영 및 실패 시 ProfileHistory 저장

<br>

✅ 요약: 프로필이 조회될 때 마다 profileId + yyyy-MM-dd 정보로 캐싱되며, 해당 정보로 캐시 유무를 판단하여 증가 처리. 하루가 지나면 스케줄링을 통해 Redis → DB로 동기화.

<br>

**🛠 트러블슈팅 및 예외 대응**

초기 조회수 증가 방식
- 기본 조회수 증가는 DB + 1이며, 일정 조회 기준이 넘었을 경우(ex - 조회수 % 10 == 0) 평등하게 캐싱 기회를 부여하여 Hot 유저를 판별하고, 그 이후 조회는 캐싱된 값을 반환하며 스케줄링 시에는 하루치 기준 조회수 달성에 미치지 못하면 Hot 유저 탈락하여 조회수 캐싱이 삭제되는 방식

해당 방식의 문제점
- 캐싱 직전 다른 100명의 조회 요청 시 해당 프로필은 +100 조회수가 추가적으로 캐싱되어야 하지만, 캐싱하려는 Thread는 DB에서 조회한 값으로 캐싱하기 때문에 실질적으로 -100 조회수 손실
- 캐싱 시 하나의 프로필에 대해 3가지 (Hot유저 일치 유무, 캐싱된 날짜, 조회수) Redis Key가 삽입되어 Redis 메모리 낭비 발생
- 


- Redis 삽입 실패 : RedisConnectionFailureException, RedisSystemException 등 캐치하여 조회수 누락 기록
- Redis 일관성 문제 :
- 동시 접근 문제: setIfAbsent + INCR 조합으로 동일한 Redis 키에 대한 중복 삽입 방지
**⏱ 조회수 복구 스케줄러**

**✅ 테스트 및 검증**

**✨ 개선 방향 및 회고**


